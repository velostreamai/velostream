================================================================================
V2 PARTITIONER ARCHITECTURE - CODE LOCATIONS & FILE PATHS
================================================================================

ABSOLUTE PATHS FOR ALL KEY FILES:

1. PARTITIONER STRATEGY DEFINITIONS
   ├─ /Users/navery/RustroverProjects/velostream/src/velostream/server/v2/partitioning_strategy.rs
   │  ├─ Line 15-29: QueryMetadata struct
   │  ├─ Line 31-48: RoutingContext struct  
   │  ├─ Line 50-75: PartitioningStrategy trait (route_record, validate, name, version)
   │  ├─ Line 87-168: AlwaysHashStrategy implementation
   │  └─ Line 170-227: Unit tests
   │
   ├─ /Users/navery/RustroverProjects/velostream/src/velostream/server/v2/smart_repartition_strategy.rs
   │  ├─ Line 38-56: SmartRepartitionStrategy struct + new()
   │  ├─ Line 99-145: route_record() implementation (alignment detection)
   │  └─ Line 166-227: Tests
   │
   ├─ /Users/navery/RustroverProjects/velostream/src/velostream/server/v2/sticky_partition_strategy.rs
   ├─ /Users/navery/RustroverProjects/velostream/src/velostream/server/v2/round_robin_strategy.rs
   └─ /Users/navery/RustroverProjects/velostream/src/velostream/server/v2/fan_in_strategy.rs

2. STRATEGY CONFIGURATION & FACTORY
   ├─ /Users/navery/RustroverProjects/velostream/src/velostream/server/v2/strategy_config.rs
   │  ├─ Line 13-50: StrategyConfig enum (AlwaysHash, SmartRepartition, RoundRobin, StickyPartition, FanIn)
   │  ├─ Line 96-118: FromStr implementation for parsing strategy names
   │  └─ Line 140-192: StrategyConfigBuilder
   │
   └─ /Users/navery/RustroverProjects/velostream/src/velostream/server/v2/strategy_factory.rs
      ├─ Line 14-38: StrategyFactory::create() - maps StrategyConfig to Arc<dyn PartitioningStrategy>
      └─ Line 50-53: StrategyFactory::create_from_str() - parses strategy name string

3. PARTITIONER SELECTION & COORDINATOR
   ├─ /Users/navery/RustroverProjects/velostream/src/velostream/server/v2/coordinator.rs
   │  ├─ Line 20-54: PartitionedJobConfig struct (contains partitioning_strategy: Option<String>)
   │  ├─ Line 166-179: PartitionedJobCoordinator struct definition
   │  ├─ Line 183-207: ✨ PARTITIONER SELECTION LOGIC - where default happens!
   │  ├─ Line 220-226: with_group_by_columns() builder method
   │  ├─ Line 229-235: with_strategy() builder method
   │  └─ Line 238-250: with_execution_engine() and with_query()
   │
   └─ /Users/navery/RustroverProjects/velostream/src/velostream/server/v2/partition_manager.rs
      ├─ Line 17-61: PartitionStateManager struct
      ├─ Line 70-73: engine field (tokio::sync::Mutex<Option<StreamExecutionEngine>>)
      └─ Line 187-250: process_record_with_sql() - where strategy would be used

4. JOB PROCESSOR INTEGRATION
   ├─ /Users/navery/RustroverProjects/velostream/src/velostream/server/v2/job_processor_v2.rs
   │  ├─ Line 32-96: JobProcessor::process_batch() implementation
   │  ├─ Line 110-250: JobProcessor::process_job() implementation (simplified)
   │  └─ Line 98-108: num_partitions(), processor_name(), processor_version()
   │
   └─ /Users/navery/RustroverProjects/velostream/src/velostream/server/v2/mod.rs
      ├─ Line 52-65: Module exports and re-exports
      └─ Line 68-88: Public API (pub use statements)

5. SQL AST STRUCTURES
   └─ /Users/navery/RustroverProjects/velostream/src/velostream/sql/ast.rs
      ├─ Line 55-70: EmitMode enum (Changes, Final)
      ├─ Line 100-137: StreamingQuery::Select variant with KEY FIELDS:
      │  ├─ group_by: Option<Vec<Expr>>              ← EXTRACT GROUP BY COLUMNS
      │  ├─ order_by: Option<Vec<OrderByExpr>>       ← EXTRACT ORDER BY COLUMNS
      │  └─ window: Option<WindowSpec>               ← DETECT WINDOWING
      ├─ Line 479-524: WindowSpec enum (Tumbling, Sliding, Session, Rows)
      ├─ Line 527-537: OrderByExpr struct
      ├─ Line 534-537: OrderDirection enum (Asc, Desc)
      └─ Line 593+: Expr enum (Column, Literal, BinaryOp, FunctionCall, etc.)

6. STREAM RECORD & TYPES
   └─ /Users/navery/RustroverProjects/velostream/src/velostream/sql/execution/types.rs
      ├─ Line 20-48: FieldValue enum (Integer, Float, String, Boolean, ScaledInteger, etc.)
      ├─ Line 54-121: Hash implementation for FieldValue
      ├─ Line 128-200: system_columns module with constants:
      │  ├─ PARTITION = "_PARTITION"
      │  ├─ OFFSET = "_OFFSET"
      │  ├─ TIMESTAMP = "_TIMESTAMP"
      │  └─ etc.
      ├─ Line 1037-1052: ✨ StreamRecord struct definition with:
      │  ├─ fields: HashMap<String, FieldValue>
      │  ├─ partition: i32                    ← SOURCE PARTITION!
      │  ├─ timestamp: i64
      │  ├─ offset: i64
      │  ├─ headers: HashMap<String, String>
      │  └─ event_time: Option<DateTime<Utc>>
      ├─ Line 1057-1114: Constructors (new, with_metadata, with_event_time)
      ├─ Line 1129-1142: get_event_time() method
      └─ Line 1145-1147: has_event_time() method

7. MODULE STRUCTURE
   └─ /Users/navery/RustroverProjects/velostream/src/velostream/server/v2/mod.rs
      ├─ pub mod coordinator;
      ├─ pub mod fan_in_strategy;
      ├─ pub mod job_processor_v2;
      ├─ pub mod metrics;
      ├─ pub mod partition_manager;
      ├─ pub mod partitioning_strategy;
      ├─ pub mod round_robin_strategy;
      ├─ pub mod smart_repartition_strategy;
      ├─ pub mod sticky_partition_strategy;
      ├─ pub mod strategy_config;
      └─ pub mod strategy_factory;

================================================================================
KEY DECISION POINTS IN CODE
================================================================================

LOCATION 1: Default Strategy Selection
  File: coordinator.rs
  Line: 183-207
  Current Code:
    let strategy = if let Some(strategy_name) = &config.partitioning_strategy {
        // Use config-provided strategy
    } else {
        // DEFAULT: AlwaysHashStrategy if no config
        Arc::new(AlwaysHashStrategy::new())
    };

LOCATION 2: GROUP BY Extraction Point
  File: ast.rs
  Line: 100-137
  Available Field:
    group_by: Option<Vec<Expr>>
  
  Needs extraction logic to convert Vec<Expr> → Vec<String>

LOCATION 3: Strategy Factory
  File: strategy_factory.rs
  Line: 30-38
  Current Code:
    pub fn create(config: StrategyConfig) -> Result<Arc<dyn PartitioningStrategy>> {
        match config {
            StrategyConfig::AlwaysHash => Ok(Arc::new(AlwaysHashStrategy::new())),
            // ... other strategies
        }
    }

LOCATION 4: Record Routing (NOT YET IMPLEMENTED)
  File: job_processor_v2.rs
  Line: 42-95
  What happens:
    - Records are read from batch
    - NOT routed to partitions by strategy
    - Just returned for downstream processing
  
  What SHOULD happen:
    - For each record:
      - Call self.strategy.route_record(&record, &context)
      - Get partition_id (0 to num_partitions-1)
      - Queue record to per-partition channel

================================================================================
FUNCTION SIGNATURES TO INTEGRATE
================================================================================

Current signature - needs query parameter:
  impl JobProcessor for PartitionedJobCoordinator {
      async fn process_job(
          &self,
          reader: Box<dyn DataReader>,
          writer: Option<Box<dyn DataWriter>>,
          engine: Arc<tokio::sync::RwLock<StreamExecutionEngine>>,
          query: StreamingQuery,                    // ← AVAILABLE HERE!
          job_name: String,
          shutdown_rx: mpsc::Receiver<()>,
      ) -> Result<JobExecutionStats, ...>
  }

To enable automatic selection, we need:
  1. Extract query characteristics early
  2. Derive RoutingContext from query AST
  3. Use StrategyFactory to create optimal strategy
  4. Pass to coordinator initialization

================================================================================
DECISION TREE FOR AUTOMATIC SELECTION
================================================================================

if has_group_by {
    if data_alignment_known && data_aligned {
        // Use SmartRepartitionStrategy (0% overhead if source partition = GROUP BY key)
        StrategyConfig::SmartRepartition
    } else {
        // Use AlwaysHashStrategy (safe, guaranteed correctness)
        StrategyConfig::AlwaysHash
    }
} else {
    if has_order_by {
        // Use StickyPartitionStrategy (maintains order within partition)
        StrategyConfig::StickyPartition
    } else if has_window {
        // Window function present but no GROUP BY - use sticky to maintain state
        StrategyConfig::StickyPartition
    } else {
        // No aggregation, no ordering - use RoundRobin for max throughput
        StrategyConfig::RoundRobin
    }
}

