application: fault_injection_demo
description: Test system resilience with various injected faults
default_timeout_ms: 120000
default_records: 200

# Comprehensive fault injection configuration
fault_injection:
  seed: 12345         # For reproducibility
  enable_dlq: true
  dlq_max_size: 200

  # Inject malformed records
  malformed_records:
    enabled: true
    rate: 0.05        # 5% malformed
    types:
      - missing_field
      - wrong_type
      - invalid_json
      - overflow

  # Inject duplicate messages
  duplicates:
    enabled: true
    rate: 0.03        # 3% duplicates

  # Inject out-of-order events
  out_of_order:
    enabled: true
    rate: 0.10        # 10% out-of-order
    max_delay_ms: 5000

  # Inject field corruption
  field_corruption:
    enabled: true
    rate: 0.02        # 2% corrupted fields
    fields:
      - quantity
      - unit_price

queries:
  - name: resilient_output
    description: Verify system survives fault injection
    inputs:
      - source: orders
        schema: order_record
        records: 200
    assertions:
      # System should process most records despite faults
      - type: record_count
        greater_than: 150    # At least 75% should succeed

      # DLQ should capture failures
      - type: dlq_count
        greater_than: 0      # Some failures expected
        less_than: 50        # But not too many

      # Job should complete (not crash)
      - type: job_status
        equals: completed

      # Output should have valid schema
      - type: schema_contains
        fields: [order_id, customer_id, total_amount, order_size]

      # Calculations should be correct for good records
      - type: field_condition
        field: total_amount
        condition: "> 0"

    timeout_ms: 120000
